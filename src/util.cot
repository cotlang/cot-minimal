// util.cot - Utility types and functions for Minimal Cot
// Part of cot-minimal: Track B of bootstrap race
//
// Uses actual Cot syntax with List<T> for dynamic arrays.

// ============================================================================
// ParseResult type for error handling
// ============================================================================

struct ParseResult {
    ok: bool,
    error_msg: string,
    error_line: u64,
    error_col: u64,
}

fn result_ok() ParseResult {
    return ParseResult{
        .ok = true,
        .error_msg = "",
        .error_line = 0,
        .error_col = 0,
    }
}

fn result_error(msg: string, line: u64, col: u64) ParseResult {
    return ParseResult{
        .ok = false,
        .error_msg = msg,
        .error_line = line,
        .error_col = col,
    }
}

// ============================================================================
// Source Location
// ============================================================================

struct SourceLoc {
    line: u64,
    column: u64,
}

fn sourceloc_new(line: u64, column: u64) SourceLoc {
    return SourceLoc{
        .line = line,
        .column = column,
    }
}

// ============================================================================
// String helpers
// ============================================================================

fn str_len(s: string) u64 {
    return len(s)
}

fn str_char_at(s: string, index: u64) u8 {
    return s[index]
}

fn str_substring(s: string, start: u64, end: u64) string {
    return s[start..end]
}

// Check if character is a digit
fn is_digit(c: u8) bool {
    return c >= 48 and c <= 57  // '0' = 48, '9' = 57
}

// Check if character is alphabetic
fn is_alpha(c: u8) bool {
    if (c >= 65 and c <= 90) { return true }   // A-Z
    if (c >= 97 and c <= 122) { return true }  // a-z
    if (c == 95) { return true }               // _
    return false
}

// Check if character is alphanumeric
fn is_alnum(c: u8) bool {
    return is_alpha(c) or is_digit(c)
}

// Check if character is whitespace
fn is_whitespace(c: u8) bool {
    if (c == 32) { return true }   // space
    if (c == 9) { return true }    // tab
    if (c == 10) { return true }   // newline
    if (c == 13) { return true }   // carriage return
    return false
}

// Convert digit character to integer
fn digit_value(c: u8) u64 {
    return c - 48  // '0' = 48
}

fn is_hex_digit(c: u8) bool {
    if (is_digit(c)) { return true }
    if (c >= 65 and c <= 70) { return true }   // A-F
    if (c >= 97 and c <= 102) { return true }  // a-f
    return false
}

// ============================================================================
// Integer helpers
// ============================================================================

fn max_u64(a: u64, b: u64) u64 {
    if (a > b) { return a }
    return b
}

fn min_u64(a: u64, b: u64) u64 {
    if (a < b) { return a }
    return b
}

// ============================================================================
// Byte buffer for bytecode output
// ============================================================================

struct ByteBuffer {
    data: List<u8>,
}

fn bytebuffer_new() *ByteBuffer {
    var bb = new ByteBuffer{
        .data = new List<u8>,
    }
    return bb
}

fn bytebuffer_len(bb: *ByteBuffer) u64 {
    return bb.data.len()
}

fn bytebuffer_write_byte(bb: *ByteBuffer, value: u8) {
    bb.data.push(value)
}

fn bytebuffer_write_u16(bb: *ByteBuffer, value: u16) {
    // Little endian
    bb.data.push((value & 0xFF) as u8)
    bb.data.push(((value >> 8) & 0xFF) as u8)
}

fn bytebuffer_write_u32(bb: *ByteBuffer, value: u32) {
    // Little endian
    bb.data.push((value & 0xFF) as u8)
    bb.data.push(((value >> 8) & 0xFF) as u8)
    bb.data.push(((value >> 16) & 0xFF) as u8)
    bb.data.push(((value >> 24) & 0xFF) as u8)
}

fn bytebuffer_write_i64(bb: *ByteBuffer, value: i64) {
    // Little endian
    var v = value as u64
    for i in 0..8 {
        bb.data.push((v & 0xFF) as u8)
        v = v >> 8
    }
}

fn bytebuffer_get_pos(bb: *ByteBuffer) u32 {
    return bb.data.len() as u32
}
