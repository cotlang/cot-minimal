// token.cot - Token types for Minimal Cot
// Part of cot-minimal: Track B of bootstrap race

// Token types - simple enum (no associated data in Minimal Cot)
enum TokenType {
    // Literals
    Integer,
    String,
    Identifier,

    // Keywords
    KwFn,
    KwVar,
    KwConst,
    KwIf,
    KwElse,
    KwWhile,
    KwFor,
    KwIn,
    KwReturn,
    KwBreak,
    KwContinue,
    KwStruct,
    KwEnum,
    KwAnd,
    KwOr,
    KwNot,
    KwTrue,
    KwFalse,
    KwNull,

    // Operators
    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    Ampersand,
    Equal,
    EqualEqual,
    BangEqual,
    Less,
    LessEqual,
    Greater,
    GreaterEqual,
    Dot,
    DotStar,
    DotDot,

    // Delimiters
    LParen,
    RParen,
    LBrace,
    RBrace,
    LBracket,
    RBracket,
    Comma,
    Colon,
    Semicolon,
    Arrow,

    // Special
    Eof,
    Error,
}

// Token structure - holds kind and position
struct Token {
    kind: TokenType,
    start: u64,
    length: u64,
    line: u64,
    column: u64,
}

// Source location for error reporting
struct SourceLoc {
    line: u64,
    column: u64,
    offset: u64,
}

// Create a new token
fn token_new(kind: TokenType, start: u64, length: u64, line: u64, column: u64) Token {
    return Token{
        .kind = kind,
        .start = start,
        .length = length,
        .line = line,
        .column = column,
    }
}

// Check if token kind is a keyword
fn is_keyword(kind: TokenType) bool {
    if (kind == TokenType.KwFn) { return true }
    if (kind == TokenType.KwVar) { return true }
    if (kind == TokenType.KwConst) { return true }
    if (kind == TokenType.KwIf) { return true }
    if (kind == TokenType.KwElse) { return true }
    if (kind == TokenType.KwWhile) { return true }
    if (kind == TokenType.KwFor) { return true }
    if (kind == TokenType.KwIn) { return true }
    if (kind == TokenType.KwReturn) { return true }
    if (kind == TokenType.KwBreak) { return true }
    if (kind == TokenType.KwContinue) { return true }
    if (kind == TokenType.KwStruct) { return true }
    if (kind == TokenType.KwEnum) { return true }
    if (kind == TokenType.KwAnd) { return true }
    if (kind == TokenType.KwOr) { return true }
    if (kind == TokenType.KwNot) { return true }
    if (kind == TokenType.KwTrue) { return true }
    if (kind == TokenType.KwFalse) { return true }
    if (kind == TokenType.KwNull) { return true }
    return false
}

// Get keyword from identifier string, or null if not a keyword
// Returns the token type, caller checks if it changed from Identifier
fn keyword_lookup(text: string) TokenType {
    if (text == "fn") { return TokenType.KwFn }
    if (text == "var") { return TokenType.KwVar }
    if (text == "const") { return TokenType.KwConst }
    if (text == "if") { return TokenType.KwIf }
    if (text == "else") { return TokenType.KwElse }
    if (text == "while") { return TokenType.KwWhile }
    if (text == "for") { return TokenType.KwFor }
    if (text == "in") { return TokenType.KwIn }
    if (text == "return") { return TokenType.KwReturn }
    if (text == "break") { return TokenType.KwBreak }
    if (text == "continue") { return TokenType.KwContinue }
    if (text == "struct") { return TokenType.KwStruct }
    if (text == "enum") { return TokenType.KwEnum }
    if (text == "and") { return TokenType.KwAnd }
    if (text == "or") { return TokenType.KwOr }
    if (text == "not") { return TokenType.KwNot }
    if (text == "true") { return TokenType.KwTrue }
    if (text == "false") { return TokenType.KwFalse }
    if (text == "null") { return TokenType.KwNull }
    return TokenType.Identifier
}

// Get string representation of token kind (for debugging)
fn token_type_name(kind: TokenType) string {
    if (kind == TokenType.Integer) { return "Integer" }
    if (kind == TokenType.String) { return "String" }
    if (kind == TokenType.Identifier) { return "Identifier" }
    if (kind == TokenType.KwFn) { return "fn" }
    if (kind == TokenType.KwVar) { return "var" }
    if (kind == TokenType.KwConst) { return "const" }
    if (kind == TokenType.KwIf) { return "if" }
    if (kind == TokenType.KwElse) { return "else" }
    if (kind == TokenType.KwWhile) { return "while" }
    if (kind == TokenType.KwFor) { return "for" }
    if (kind == TokenType.KwIn) { return "in" }
    if (kind == TokenType.KwReturn) { return "return" }
    if (kind == TokenType.KwBreak) { return "break" }
    if (kind == TokenType.KwContinue) { return "continue" }
    if (kind == TokenType.KwStruct) { return "struct" }
    if (kind == TokenType.KwEnum) { return "enum" }
    if (kind == TokenType.KwAnd) { return "and" }
    if (kind == TokenType.KwOr) { return "or" }
    if (kind == TokenType.KwNot) { return "not" }
    if (kind == TokenType.KwTrue) { return "true" }
    if (kind == TokenType.KwFalse) { return "false" }
    if (kind == TokenType.KwNull) { return "null" }
    if (kind == TokenType.Plus) { return "+" }
    if (kind == TokenType.Minus) { return "-" }
    if (kind == TokenType.Star) { return "*" }
    if (kind == TokenType.Slash) { return "/" }
    if (kind == TokenType.Percent) { return "%" }
    if (kind == TokenType.Ampersand) { return "&" }
    if (kind == TokenType.Equal) { return "=" }
    if (kind == TokenType.EqualEqual) { return "==" }
    if (kind == TokenType.BangEqual) { return "!=" }
    if (kind == TokenType.Less) { return "<" }
    if (kind == TokenType.LessEqual) { return "<=" }
    if (kind == TokenType.Greater) { return ">" }
    if (kind == TokenType.GreaterEqual) { return ">=" }
    if (kind == TokenType.Dot) { return "." }
    if (kind == TokenType.DotStar) { return ".*" }
    if (kind == TokenType.DotDot) { return ".." }
    if (kind == TokenType.LParen) { return "(" }
    if (kind == TokenType.RParen) { return ")" }
    if (kind == TokenType.LBrace) { return "{" }
    if (kind == TokenType.RBrace) { return "}" }
    if (kind == TokenType.LBracket) { return "[" }
    if (kind == TokenType.RBracket) { return "]" }
    if (kind == TokenType.Comma) { return "," }
    if (kind == TokenType.Colon) { return ":" }
    if (kind == TokenType.Semicolon) { return ";" }
    if (kind == TokenType.Arrow) { return "->" }
    if (kind == TokenType.Eof) { return "EOF" }
    if (kind == TokenType.Error) { return "Error" }
    return "Unknown"
}
